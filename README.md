初次评测文件：
增添一个功能就是再生成一个jsonl文件里面能够按调用频次顺序存储一下记忆条目。比如说排名，记忆ID，调用频次之类的就这种。
聚类文件：
对原数据集进行聚类后，除了生成现在写的一个带有类别名字的新记忆库，再输出一个jsonl文件，里面写的内容是这样：类ID：记忆ID。即陈列每个类内都有哪些记忆ID。然后再利用之前的
MATH-lighteval_memory_freq_20251209_231530.jsonl 文件，算一下每个类的总调用频次，也写在里面。 类ID的排序就按数字排序吧，也方便后续优化的时候查找和调用。
优化文件：
它会先有一个参数k，能够先去调取MATH-lighteval_memory_freq_20251209_231530.jsonl里面排名在前k的作为高频记忆。在_auto_clustered_result.jsonl，对高频记忆进行一个类内优化，就是先在_cluster_summary.jsonl读选类内的条目有哪些，之后计算和本条记忆相似度的top n（这是可以利用flashrag的代码，如果没法用就不用自己写），然后直接调用大模型（和之前一样，还是要有gemini和本地qwen两种方法）进行一个信息总结和扩展。高频记忆优化后，如果被合并的记忆里有频次低于低阈值的，那么直接将其消去。 之后处理_auto_clustered_result.jsonl，将调取频次为0的直接删掉。去调取MATH-lighteval_memory_freq_20251209_231530.jsonl里面排名在后k的作为低频记忆。对低频记忆（只考虑调用次数为1的，所有为0的直接删除）（没有被高频合并而消去的）进行不更改核心语义，不增添额外信息的语义扩展。 不更改原数据集，只更改_auto_clustered_result.jsonl，之后将这个文件变成一个新的记忆库，为之后的rag调用。
最终测试文件：
训练集 → 频次统计 → 聚类 → 优化记忆库 → ✅ 最终只用测试集做一次正式评测。